// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookmarks.sql

package db

import (
	"context"
)

const addBookmarkTag = `-- name: AddBookmarkTag :exec
INSERT INTO bookmark_tags (bookmark_id, tag_id, created_at) VALUES (?, ?, CURRENT_TIMESTAMP)
`

type AddBookmarkTagParams struct {
	BookmarkID int64 `json:"bookmark_id"`
	TagID      int64 `json:"tag_id"`
}

func (q *Queries) AddBookmarkTag(ctx context.Context, arg AddBookmarkTagParams) error {
	_, err := q.db.ExecContext(ctx, addBookmarkTag, arg.BookmarkID, arg.TagID)
	return err
}

const countAllBookmarks = `-- name: CountAllBookmarks :one
SELECT COUNT(*) FROM bookmarks
`

func (q *Queries) CountAllBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBookmarksByCollection = `-- name: CountBookmarksByCollection :one
SELECT COUNT(*) FROM bookmarks WHERE collection_id = ?
`

func (q *Queries) CountBookmarksByCollection(ctx context.Context, collectionID *int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookmarksByCollection, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFavoriteBookmarks = `-- name: CountFavoriteBookmarks :one
SELECT COUNT(*) FROM bookmarks WHERE is_favorite = 1
`

func (q *Queries) CountFavoriteBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFavoriteBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicBookmarks = `-- name: CountPublicBookmarks :one
SELECT COUNT(*) FROM bookmarks WHERE is_public = 1
`

func (q *Queries) CountPublicBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublicBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicBookmarksByCollection = `-- name: CountPublicBookmarksByCollection :one
SELECT COUNT(*) FROM bookmarks WHERE is_public = 1 AND collection_id = ?
`

func (q *Queries) CountPublicBookmarksByCollection(ctx context.Context, collectionID *int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublicBookmarksByCollection, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicFavoriteBookmarks = `-- name: CountPublicFavoriteBookmarks :one
SELECT COUNT(*) FROM bookmarks WHERE is_public = 1 AND is_favorite = 1
`

func (q *Queries) CountPublicFavoriteBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublicFavoriteBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBookmark = `-- name: CreateBookmark :one
INSERT INTO bookmarks (url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at
`

type CreateBookmarkParams struct {
	Url          string  `json:"url"`
	Title        string  `json:"title"`
	Description  *string `json:"description"`
	Excerpt      *string `json:"excerpt"`
	CoverImage   *string `json:"cover_image"`
	Favicon      *string `json:"favicon"`
	Domain       *string `json:"domain"`
	CollectionID *int64  `json:"collection_id"`
	IsPublic     *int64  `json:"is_public"`
	IsFavorite   *int64  `json:"is_favorite"`
	SortOrder    *int64  `json:"sort_order"`
}

func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, createBookmark,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.Excerpt,
		arg.CoverImage,
		arg.Favicon,
		arg.Domain,
		arg.CollectionID,
		arg.IsPublic,
		arg.IsFavorite,
		arg.SortOrder,
	)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.Excerpt,
		&i.CoverImage,
		&i.Favicon,
		&i.Domain,
		&i.CollectionID,
		&i.IsPublic,
		&i.IsFavorite,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks WHERE id = ?
`

func (q *Queries) DeleteBookmark(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBookmark, id)
	return err
}

const deleteBookmarkTags = `-- name: DeleteBookmarkTags :exec
DELETE FROM bookmark_tags WHERE bookmark_id = ?
`

func (q *Queries) DeleteBookmarkTags(ctx context.Context, bookmarkID int64) error {
	_, err := q.db.ExecContext(ctx, deleteBookmarkTags, bookmarkID)
	return err
}

const getBookmarkByID = `-- name: GetBookmarkByID :one
SELECT id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks WHERE id = ?
`

func (q *Queries) GetBookmarkByID(ctx context.Context, id int64) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, getBookmarkByID, id)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.Excerpt,
		&i.CoverImage,
		&i.Favicon,
		&i.Domain,
		&i.CollectionID,
		&i.IsPublic,
		&i.IsFavorite,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookmarkTags = `-- name: GetBookmarkTags :many
SELECT t.id, t.name, t.slug, t.color, t.created_at
FROM tags t
INNER JOIN bookmark_tags bt ON t.id = bt.tag_id
WHERE bt.bookmark_id = ?
`

func (q *Queries) GetBookmarkTags(ctx context.Context, bookmarkID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getBookmarkTags, bookmarkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllBookmarks = `-- name: ListAllBookmarks :many
SELECT id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListAllBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListAllBookmarks(ctx context.Context, arg ListAllBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listAllBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Excerpt,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookmarksByCollection = `-- name: ListBookmarksByCollection :many
SELECT id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE collection_id = ? 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListBookmarksByCollectionParams struct {
	CollectionID *int64 `json:"collection_id"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

func (q *Queries) ListBookmarksByCollection(ctx context.Context, arg ListBookmarksByCollectionParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listBookmarksByCollection, arg.CollectionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Excerpt,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoriteBookmarks = `-- name: ListFavoriteBookmarks :many
SELECT id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_favorite = 1 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListFavoriteBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListFavoriteBookmarks(ctx context.Context, arg ListFavoriteBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listFavoriteBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Excerpt,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicBookmarks = `-- name: ListPublicBookmarks :many
SELECT id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_public = 1 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListPublicBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPublicBookmarks(ctx context.Context, arg ListPublicBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listPublicBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Excerpt,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicBookmarksByCollection = `-- name: ListPublicBookmarksByCollection :many
SELECT id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_public = 1 AND collection_id = ? 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListPublicBookmarksByCollectionParams struct {
	CollectionID *int64 `json:"collection_id"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

func (q *Queries) ListPublicBookmarksByCollection(ctx context.Context, arg ListPublicBookmarksByCollectionParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listPublicBookmarksByCollection, arg.CollectionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Excerpt,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicFavoriteBookmarks = `-- name: ListPublicFavoriteBookmarks :many
SELECT id, url, title, description, excerpt, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_public = 1 AND is_favorite = 1 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListPublicFavoriteBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPublicFavoriteBookmarks(ctx context.Context, arg ListPublicFavoriteBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listPublicFavoriteBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.Excerpt,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookmark = `-- name: UpdateBookmark :exec
UPDATE bookmarks 
SET url = ?, title = ?, description = ?, cover_image = ?, domain = ?,
    collection_id = ?, is_public = ?, is_favorite = ?, updated_at = CURRENT_TIMESTAMP 
WHERE id = ?
`

type UpdateBookmarkParams struct {
	Url          string  `json:"url"`
	Title        string  `json:"title"`
	Description  *string `json:"description"`
	CoverImage   *string `json:"cover_image"`
	Domain       *string `json:"domain"`
	CollectionID *int64  `json:"collection_id"`
	IsPublic     *int64  `json:"is_public"`
	IsFavorite   *int64  `json:"is_favorite"`
	ID           int64   `json:"id"`
}

func (q *Queries) UpdateBookmark(ctx context.Context, arg UpdateBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, updateBookmark,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.CoverImage,
		arg.Domain,
		arg.CollectionID,
		arg.IsPublic,
		arg.IsFavorite,
		arg.ID,
	)
	return err
}
