// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookmarks.sql

package db

import (
	"context"
	"time"
)

const countAllBookmarks = `-- name: CountAllBookmarks :one
SELECT COUNT(*) FROM bookmarks
`

func (q *Queries) CountAllBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBookmarksByCollection = `-- name: CountBookmarksByCollection :one
SELECT COUNT(*) FROM bookmarks WHERE collection_id = ?
`

func (q *Queries) CountBookmarksByCollection(ctx context.Context, collectionID *int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookmarksByCollection, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFavoriteBookmarks = `-- name: CountFavoriteBookmarks :one
SELECT COUNT(*) FROM bookmarks WHERE is_favorite = 1
`

func (q *Queries) CountFavoriteBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFavoriteBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicBookmarks = `-- name: CountPublicBookmarks :one
SELECT COUNT(*) FROM bookmarks WHERE is_public = 1
`

func (q *Queries) CountPublicBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublicBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicBookmarksByCollection = `-- name: CountPublicBookmarksByCollection :one
SELECT COUNT(*) FROM bookmarks WHERE is_public = 1 AND collection_id = ?
`

func (q *Queries) CountPublicBookmarksByCollection(ctx context.Context, collectionID *int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublicBookmarksByCollection, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicFavoriteBookmarks = `-- name: CountPublicFavoriteBookmarks :one
SELECT COUNT(*) FROM bookmarks WHERE is_public = 1 AND is_favorite = 1
`

func (q *Queries) CountPublicFavoriteBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublicFavoriteBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnsortedBookmarks = `-- name: CountUnsortedBookmarks :one

SELECT COUNT(*) FROM bookmarks WHERE collection_id IS NULL
`

// ============================================
// BOARD VIEW QUERIES
// ============================================
func (q *Queries) CountUnsortedBookmarks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnsortedBookmarks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBookmark = `-- name: CreateBookmark :one
INSERT INTO bookmarks (url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at
`

type CreateBookmarkParams struct {
	Url          string  `json:"url"`
	Title        string  `json:"title"`
	Description  *string `json:"description"`
	CoverImage   *string `json:"cover_image"`
	Favicon      *string `json:"favicon"`
	Domain       *string `json:"domain"`
	CollectionID *int64  `json:"collection_id"`
	IsPublic     *int64  `json:"is_public"`
	IsFavorite   *int64  `json:"is_favorite"`
	SortOrder    *int64  `json:"sort_order"`
}

func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, createBookmark,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.CoverImage,
		arg.Favicon,
		arg.Domain,
		arg.CollectionID,
		arg.IsPublic,
		arg.IsFavorite,
		arg.SortOrder,
	)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.CoverImage,
		&i.Favicon,
		&i.Domain,
		&i.CollectionID,
		&i.IsPublic,
		&i.IsFavorite,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks WHERE id = ?
`

func (q *Queries) DeleteBookmark(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBookmark, id)
	return err
}

const getBookmarkByID = `-- name: GetBookmarkByID :one
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks WHERE id = ?
`

func (q *Queries) GetBookmarkByID(ctx context.Context, id int64) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, getBookmarkByID, id)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.CoverImage,
		&i.Favicon,
		&i.Domain,
		&i.CollectionID,
		&i.IsPublic,
		&i.IsFavorite,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookmarkByURL = `-- name: GetBookmarkByURL :one
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks WHERE url = ? LIMIT 1
`

func (q *Queries) GetBookmarkByURL(ctx context.Context, url string) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, getBookmarkByURL, url)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.CoverImage,
		&i.Favicon,
		&i.Domain,
		&i.CollectionID,
		&i.IsPublic,
		&i.IsFavorite,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionBookmarkSortOrders = `-- name: GetCollectionBookmarkSortOrders :many

SELECT id, COALESCE(sort_order, 999999) as sort_order
FROM bookmarks
WHERE collection_id = ?
ORDER BY COALESCE(sort_order, 999999) ASC, updated_at DESC
`

type GetCollectionBookmarkSortOrdersRow struct {
	ID        int64 `json:"id"`
	SortOrder int64 `json:"sort_order"`
}

// ============================================
// POSITION/SORT ORDER QUERIES
// ============================================
func (q *Queries) GetCollectionBookmarkSortOrders(ctx context.Context, collectionID *int64) ([]GetCollectionBookmarkSortOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionBookmarkSortOrders, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCollectionBookmarkSortOrdersRow{}
	for rows.Next() {
		var i GetCollectionBookmarkSortOrdersRow
		if err := rows.Scan(&i.ID, &i.SortOrder); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnsortedBookmarkSortOrders = `-- name: GetUnsortedBookmarkSortOrders :many
SELECT id, COALESCE(sort_order, 999999) as sort_order
FROM bookmarks
WHERE collection_id IS NULL
ORDER BY COALESCE(sort_order, 999999) ASC, updated_at DESC
`

type GetUnsortedBookmarkSortOrdersRow struct {
	ID        int64 `json:"id"`
	SortOrder int64 `json:"sort_order"`
}

func (q *Queries) GetUnsortedBookmarkSortOrders(ctx context.Context) ([]GetUnsortedBookmarkSortOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnsortedBookmarkSortOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnsortedBookmarkSortOrdersRow{}
	for rows.Next() {
		var i GetUnsortedBookmarkSortOrdersRow
		if err := rows.Scan(&i.ID, &i.SortOrder); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllBookmarks = `-- name: ListAllBookmarks :many
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListAllBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListAllBookmarks(ctx context.Context, arg ListAllBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listAllBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookmarksByCollection = `-- name: ListBookmarksByCollection :many
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE collection_id = ? 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListBookmarksByCollectionParams struct {
	CollectionID *int64 `json:"collection_id"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

func (q *Queries) ListBookmarksByCollection(ctx context.Context, arg ListBookmarksByCollectionParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listBookmarksByCollection, arg.CollectionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoriteBookmarks = `-- name: ListFavoriteBookmarks :many
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_favorite = 1 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListFavoriteBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListFavoriteBookmarks(ctx context.Context, arg ListFavoriteBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listFavoriteBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicBookmarks = `-- name: ListPublicBookmarks :many
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_public = 1 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListPublicBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPublicBookmarks(ctx context.Context, arg ListPublicBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listPublicBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicBookmarksByCollection = `-- name: ListPublicBookmarksByCollection :many
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_public = 1 AND collection_id = ? 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListPublicBookmarksByCollectionParams struct {
	CollectionID *int64 `json:"collection_id"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

func (q *Queries) ListPublicBookmarksByCollection(ctx context.Context, arg ListPublicBookmarksByCollectionParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listPublicBookmarksByCollection, arg.CollectionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicFavoriteBookmarks = `-- name: ListPublicFavoriteBookmarks :many
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks 
WHERE is_public = 1 AND is_favorite = 1 
ORDER BY sort_order, created_at DESC 
LIMIT ? OFFSET ?
`

type ListPublicFavoriteBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPublicFavoriteBookmarks(ctx context.Context, arg ListPublicFavoriteBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listPublicFavoriteBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentUnsortedBookmarks = `-- name: ListRecentUnsortedBookmarks :many
SELECT id, title, url, domain, is_favorite, is_public, updated_at
FROM bookmarks
WHERE collection_id IS NULL
ORDER BY COALESCE(sort_order, 999999) ASC, updated_at DESC
LIMIT ?
`

type ListRecentUnsortedBookmarksRow struct {
	ID         int64      `json:"id"`
	Title      string     `json:"title"`
	Url        string     `json:"url"`
	Domain     *string    `json:"domain"`
	IsFavorite *int64     `json:"is_favorite"`
	IsPublic   *int64     `json:"is_public"`
	UpdatedAt  *time.Time `json:"updated_at"`
}

func (q *Queries) ListRecentUnsortedBookmarks(ctx context.Context, limit int64) ([]ListRecentUnsortedBookmarksRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentUnsortedBookmarks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentUnsortedBookmarksRow{}
	for rows.Next() {
		var i ListRecentUnsortedBookmarksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Url,
			&i.Domain,
			&i.IsFavorite,
			&i.IsPublic,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnsortedBookmarks = `-- name: ListUnsortedBookmarks :many
SELECT id, url, title, description, cover_image, favicon, domain, collection_id, is_public, is_favorite, sort_order, created_at, updated_at FROM bookmarks
WHERE collection_id IS NULL
ORDER BY COALESCE(sort_order, 999999) ASC, updated_at DESC
LIMIT ? OFFSET ?
`

type ListUnsortedBookmarksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListUnsortedBookmarks(ctx context.Context, arg ListUnsortedBookmarksParams) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listUnsortedBookmarks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Favicon,
			&i.Domain,
			&i.CollectionID,
			&i.IsPublic,
			&i.IsFavorite,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookmark = `-- name: UpdateBookmark :exec
UPDATE bookmarks 
SET url = ?, title = ?, description = ?, cover_image = ?, favicon = ?, domain = ?,
    collection_id = ?, is_public = ?, is_favorite = ?, updated_at = CURRENT_TIMESTAMP 
WHERE id = ?
`

type UpdateBookmarkParams struct {
	Url          string  `json:"url"`
	Title        string  `json:"title"`
	Description  *string `json:"description"`
	CoverImage   *string `json:"cover_image"`
	Favicon      *string `json:"favicon"`
	Domain       *string `json:"domain"`
	CollectionID *int64  `json:"collection_id"`
	IsPublic     *int64  `json:"is_public"`
	IsFavorite   *int64  `json:"is_favorite"`
	ID           int64   `json:"id"`
}

func (q *Queries) UpdateBookmark(ctx context.Context, arg UpdateBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, updateBookmark,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.CoverImage,
		arg.Favicon,
		arg.Domain,
		arg.CollectionID,
		arg.IsPublic,
		arg.IsFavorite,
		arg.ID,
	)
	return err
}

const updateBookmarkFavorite = `-- name: UpdateBookmarkFavorite :exec
UPDATE bookmarks SET is_favorite = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateBookmarkFavoriteParams struct {
	IsFavorite *int64 `json:"is_favorite"`
	ID         int64  `json:"id"`
}

func (q *Queries) UpdateBookmarkFavorite(ctx context.Context, arg UpdateBookmarkFavoriteParams) error {
	_, err := q.db.ExecContext(ctx, updateBookmarkFavorite, arg.IsFavorite, arg.ID)
	return err
}

const updateBookmarkPosition = `-- name: UpdateBookmarkPosition :exec
UPDATE bookmarks 
SET collection_id = ?, sort_order = ?, updated_at = CURRENT_TIMESTAMP 
WHERE id = ?
`

type UpdateBookmarkPositionParams struct {
	CollectionID *int64 `json:"collection_id"`
	SortOrder    *int64 `json:"sort_order"`
	ID           int64  `json:"id"`
}

func (q *Queries) UpdateBookmarkPosition(ctx context.Context, arg UpdateBookmarkPositionParams) error {
	_, err := q.db.ExecContext(ctx, updateBookmarkPosition, arg.CollectionID, arg.SortOrder, arg.ID)
	return err
}

const updateBookmarkPublic = `-- name: UpdateBookmarkPublic :exec

UPDATE bookmarks SET is_public = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateBookmarkPublicParams struct {
	IsPublic *int64 `json:"is_public"`
	ID       int64  `json:"id"`
}

// ============================================
// INLINE EDITING QUERIES
// ============================================
func (q *Queries) UpdateBookmarkPublic(ctx context.Context, arg UpdateBookmarkPublicParams) error {
	_, err := q.db.ExecContext(ctx, updateBookmarkPublic, arg.IsPublic, arg.ID)
	return err
}
