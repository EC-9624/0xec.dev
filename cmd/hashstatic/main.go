// Command hashstatic generates content-hashed filenames for static assets.
// It computes SHA256 hashes of CSS/JS files and generates a manifest for runtime lookup.
//
// Usage:
//
//	go run ./cmd/hashstatic        # Production: hash files and generate manifest
//	go run ./cmd/hashstatic -dev   # Development: generate identity manifest (no hashing)
package main

import (
	"crypto/sha256"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const (
	staticDir   = "web/static"
	manifestDir = "internal/assets"
	manifestFile = "manifest_gen.go"
)

// Files to hash - CSS and JS files that are referenced in templates
var filesToHash = []string{
	// CSS
	"css/output.css",
	// JS - core
	"js/theme.js",
	"js/htmx.min.js",
	"js/masonry.js",
	"js/filter.js",
	"js/prefetch.js",
	"js/progress-bar.js",
	"js/utils.js",
	"js/validation.js",
	"js/expandable-row.js",
	"js/kanban.js",
	// JS - components
	"js/components/ec-dropdown.js",
	"js/components/ec-mobile-nav.js",
	"js/components/ec-drawer.js",
	"js/components/ec-tag-select.js",
	"js/components/ec-toast-container.js",
}

func main() {
	devMode := flag.Bool("dev", false, "Development mode: generate identity manifest without hashing")
	flag.Parse()

	if *devMode {
		if err := generateDevManifest(); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating dev manifest: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("Generated development manifest (identity mapping)")
		return
	}

	if err := hashAssets(); err != nil {
		fmt.Fprintf(os.Stderr, "Error hashing assets: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("Successfully hashed assets and generated manifest")
}

// hashAssets computes hashes for all static files, copies them to hashed filenames,
// and generates the manifest file.
func hashAssets() error {
	manifest := make(map[string]string)

	for _, file := range filesToHash {
		srcPath := filepath.Join(staticDir, file)

		// Read file content
		content, err := os.ReadFile(srcPath)
		if err != nil {
			return fmt.Errorf("reading %s: %w", file, err)
		}

		// Compute hash (first 8 hex chars of SHA256)
		hash := sha256.Sum256(content)
		hashStr := fmt.Sprintf("%x", hash[:4]) // 4 bytes = 8 hex chars

		// Generate hashed filename
		ext := filepath.Ext(file)
		base := strings.TrimSuffix(file, ext)
		hashedFile := fmt.Sprintf("%s.%s%s", base, hashStr, ext)
		hashedPath := filepath.Join(staticDir, hashedFile)

		// Copy to hashed filename
		if err := copyFile(srcPath, hashedPath); err != nil {
			return fmt.Errorf("copying to %s: %w", hashedFile, err)
		}

		// Add to manifest
		manifest[file] = "/static/" + hashedFile
		fmt.Printf("  %s â†’ %s\n", file, hashedFile)
	}

	// Generate manifest file
	if err := generateManifest(manifest); err != nil {
		return fmt.Errorf("generating manifest: %w", err)
	}

	return nil
}

// generateDevManifest creates an identity manifest for development mode.
// This avoids the overhead of hashing during development.
func generateDevManifest() error {
	manifest := make(map[string]string)
	for _, file := range filesToHash {
		manifest[file] = "/static/" + file
	}
	return generateManifest(manifest)
}

// generateManifest writes the manifest_gen.go file with the asset mappings.
func generateManifest(manifest map[string]string) error {
	// Ensure directory exists
	if err := os.MkdirAll(manifestDir, 0755); err != nil {
		return err
	}

	// Sort keys for deterministic output
	keys := make([]string, 0, len(manifest))
	for k := range manifest {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Build file content
	var sb strings.Builder
	sb.WriteString("// Code generated by cmd/hashstatic. DO NOT EDIT.\n\n")
	sb.WriteString("package assets\n\n")
	sb.WriteString("// manifest maps original asset paths to their hashed versions.\n")
	sb.WriteString("var manifest = map[string]string{\n")
	for _, k := range keys {
		sb.WriteString(fmt.Sprintf("\t%q: %q,\n", k, manifest[k]))
	}
	sb.WriteString("}\n")

	// Write file
	path := filepath.Join(manifestDir, manifestFile)
	if err := os.WriteFile(path, []byte(sb.String()), 0644); err != nil {
		return err
	}

	return nil
}

// copyFile copies a file from src to dst.
func copyFile(src, dst string) error {
	// Ensure destination directory exists
	if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil {
		return err
	}

	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	if _, err := io.Copy(dstFile, srcFile); err != nil {
		return err
	}

	return dstFile.Sync()
}
