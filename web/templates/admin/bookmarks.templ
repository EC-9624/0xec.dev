package admin

import (
	"context"
	"strconv"

	"github.com/EC-9624/0xec.dev/internal/middleware"
	"github.com/EC-9624/0xec.dev/internal/models"
	"github.com/EC-9624/0xec.dev/web/templates/components"
	"github.com/EC-9624/0xec.dev/web/templates/layouts"
)

// getCSPNonce retrieves the CSP nonce from context for inline scripts
func getCSPNonce(ctx context.Context) string {
	nonce, ok := ctx.Value(middleware.CSPNonceContextKey).(string)
	if !ok {
		return ""
	}
	return nonce
}

// getCSRFToken retrieves the CSRF token from context
func getBookmarkCSRFToken(ctx context.Context) string {
	token, ok := ctx.Value(middleware.CSRFTokenContextKey).(string)
	if !ok {
		return ""
	}
	return token
}

// BookmarksListData contains data for the bookmarks list page
type BookmarksListData struct {
	Bookmarks   []models.Bookmark
	Collections []models.Collection
}

templ BookmarksList(data BookmarksListData) {
	@layouts.Admin("Bookmarks") {
		<div class="space-y-4">
			<!-- Header -->
			@components.PageHeader("Bookmarks", strconv.Itoa(len(data.Bookmarks))+" bookmarks") {
				@components.RefreshButton("refresh-btn", "startMetadataRefresh()", "Refresh Metadata")
				@components.ImportButton("/admin/import")
				@components.NewButton("/admin/bookmarks/new", "New Bookmark")
			}
			<!-- Refresh Progress Banner (hidden by default) -->
			<div id="refresh-progress" class="hidden">
				<div class="bg-muted border border-border p-4 space-y-2">
					<div class="flex items-center justify-between">
						<span id="refresh-status" class="text-sm font-medium">Preparing...</span>
						<span id="refresh-count" class="text-sm text-muted-foreground"></span>
					</div>
					<div class="w-full bg-border h-2">
						<div id="refresh-bar" class="bg-primary h-2 transition-all duration-300 w-0"></div>
					</div>
					<p id="refresh-current" class="text-xs text-muted-foreground truncate"></p>
				</div>
			</div>
			<!-- Filters Bar -->
			@components.FilterBar(components.FilterBarProps{}) {
				@components.SearchInput(components.SearchInputProps{
					ID:          "bookmark-search",
					Placeholder: "Search bookmarks...",
					OnInput:     "bookmarksFilter.apply()",
				})
				<!-- Collection Filter (custom with dynamic options) -->
				@bookmarkCollectionFilter(data.Collections)
				@components.FilterDropdown(components.FilterDropdownProps{
					ID:           "status-filter",
					DefaultLabel: "All Status",
					Options:      components.BookmarkStatusOptions(),
					OnChange:     "bookmarksFilter.apply()",
				})
				@components.ClearFiltersButton("bookmarksFilter.clear()")
			}
			<!-- Table -->
			if len(data.Bookmarks) > 0 {
				<div class="card overflow-hidden">
					<table class="table" id="bookmarks-table">
						<thead class="table-header bg-muted/50">
							<tr class="table-row">
								<th class="table-head w-[50%]">Title</th>
								<th class="table-head w-[20%]">Collection</th>
								<th class="table-head w-[15%]">Status</th>
								<th class="table-head w-[15%] text-right">Actions</th>
							</tr>
						</thead>
						<tbody class="table-body" id="bookmarks-tbody">
							for _, bookmark := range data.Bookmarks {
								@bookmarkRow(bookmark, data.Collections)
							}
						</tbody>
					</table>
				</div>
				<!-- No results message (hidden by default) -->
				@components.NoResults("bookmarks", "bookmarksFilter.clear")
			} else {
				@components.EmptyState(components.EmptyStateProps{
					Icon:        components.BookmarkIcon(components.IconXXL),
					Title:       "No bookmarks yet",
					Description: "Start saving interesting links.",
					CTAHref:     "/admin/bookmarks/new",
					CTAText:     "Add your first bookmark",
				})
			}
		</div>
		<!-- Client-side filtering script -->
		@bookmarksFilterScript()
	}
}

templ bookmarkRow(bookmark models.Bookmark, collections []models.Collection) {
	<tr
		class="table-row group"
		data-title={ bookmark.Title }
		data-url={ bookmark.URL }
		data-domain={ bookmark.GetDomain() }
		data-collection-id={ getCollectionID(bookmark) }
		data-is-public={ strconv.FormatBool(bookmark.IsPublic) }
		data-is-favorite={ strconv.FormatBool(bookmark.IsFavorite) }
	>
		<!-- Title (inline editable) -->
		<td class="table-cell overflow-hidden">
			<div class="flex items-center gap-2 min-w-0">
				<!-- Favicon -->
				<div class="w-6 h-6 bg-muted flex items-center justify-center text-xs text-muted-foreground shrink-0 overflow-hidden">
					<img
						src={ bookmark.GetFaviconURL() }
						alt=""
						class="w-4 h-4 object-contain"
						loading="lazy"
						data-show-fallback
					/>
					<span class="bookmark-card-fallback hidden items-center justify-center w-full h-full text-[10px]">{ getFirstLetter(bookmark.GetDomain()) }</span>
				</div>
				@BookmarkTitleDisplay(bookmark.ID, bookmark.Title, bookmark.URL, false)
			</div>
		</td>
		<!-- Collection (inline dropdown) -->
		<td class="table-cell">
			@BookmarkCollectionDropdown(bookmark.ID, bookmark.CollectionID.Int64, bookmark.CollectionID.Valid, collections, false)
		</td>
		<!-- Status (inline toggles) -->
		<td class="table-cell">
			<div class="flex items-center gap-1">
				@BookmarkPublicBadge(bookmark.ID, bookmark.IsPublic, false)
				@BookmarkFavoriteStar(bookmark.ID, bookmark.IsFavorite, false)
			</div>
		</td>
		<!-- Actions -->
		<td class="table-cell text-right">
			<div class="row-actions">
				<a
					href={ templ.URL(bookmark.URL) }
					class="btn-ghost btn-xs"
					target="_blank"
					title="Open link"
				>
					@components.ExternalLinkIcon(components.IconMD)
				</a>
				<a
					href={ templ.URL("/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) + "/edit") }
					class="btn-ghost btn-xs"
					title="Full edit"
				>
					@components.EditIcon(components.IconMD)
				</a>
				<button
					type="button"
					hx-delete={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
					hx-confirm="Delete this bookmark?"
					hx-target="closest tr"
					hx-swap="outerHTML swap:0.2s"
					class="btn-ghost btn-xs text-destructive hover:text-destructive"
					title="Delete"
				>
					@components.TrashIcon(components.IconMD)
				</button>
			</div>
		</td>
	</tr>
}

templ bookmarksFilterScript() {
	<script nonce={ getCSPNonce(ctx) }>
		// Initialize table filter using the reusable TableFilter class
		const bookmarksFilter = new TableFilter({
			tableBodyId: 'bookmarks-tbody',
			searchId: 'bookmark-search',
			filters: [
				{ id: 'collection-filter', match: TableFilter.collectionMatcher },
				{ id: 'status-filter', match: TableFilter.bookmarkStatusMatcher }
			],
			searchFields: ['title', 'url', 'domain'],
			storageKey: 'bookmarkFilters',
			tableCardSelector: '.card:has(#bookmarks-table)'
		});

		// Initialize on DOM ready
		document.addEventListener('DOMContentLoaded', () => bookmarksFilter.init());

		// Metadata refresh with SSE progress
		function startMetadataRefresh() {
			const btn = document.getElementById('refresh-btn');
			const btnText = document.getElementById('refresh-btn-text');
			const progress = document.getElementById('refresh-progress');
			const status = document.getElementById('refresh-status');
			const count = document.getElementById('refresh-count');
			const bar = document.getElementById('refresh-bar');
			const current = document.getElementById('refresh-current');

			// Disable button and show progress
			btn.disabled = true;
			btn.classList.add('opacity-50');
			btnText.textContent = 'Refreshing...';
			progress.classList.remove('hidden');
			status.textContent = 'Connecting...';
			bar.style.width = '0%';

			const eventSource = new EventSource('/admin/bookmarks/refresh-all');

			eventSource.onmessage = (event) => {
				const parts = event.data.split(':');
				const type = parts[0];

				if (type === 'start') {
					const total = parts[1];
					status.textContent = 'Refreshing metadata...';
					count.textContent = `0 / ${total}`;
				} else if (type === 'progress') {
					const current_num = parseInt(parts[1]);
					const total = parseInt(parts[2]);
					const title = parts.slice(3).join(':'); // Title might contain colons
					const pct = Math.round((current_num / total) * 100);
					bar.style.width = pct + '%';
					count.textContent = `${current_num} / ${total}`;
					current.textContent = `Processing: ${title}`;
				} else if (type === 'done') {
					const updated = parts[1];
					const failed = parts[2];
					eventSource.close();
					
					status.textContent = 'Completed!';
					bar.style.width = '100%';
					current.textContent = `Updated: ${updated}, Failed: ${failed}`;
					count.textContent = '';
					
					// Re-enable button
					btn.disabled = false;
					btn.classList.remove('opacity-50');
					btnText.textContent = 'Refresh Metadata';

					// Hide progress after 3 seconds and reload
					setTimeout(() => {
						progress.classList.add('hidden');
						window.location.reload();
					}, 2000);
				} else if (type === 'error') {
					eventSource.close();
					status.textContent = 'Error: ' + parts.slice(1).join(':');
					bar.style.width = '0%';
					btn.disabled = false;
					btn.classList.remove('opacity-50');
					btnText.textContent = 'Refresh Metadata';
				}
			};

			eventSource.onerror = () => {
				eventSource.close();
				status.textContent = 'Connection error';
				btn.disabled = false;
				btn.classList.remove('opacity-50');
				btnText.textContent = 'Refresh Metadata';
			};
		}

		// Listen for HX-Trigger events to update row data attributes for filtering
		document.body.addEventListener('updateRowData', (e) => {
			const data = e.detail;
			if (!data || !data.id) return;

			// Find the row by looking for any element with data-bookmark-id or the tr itself
			const row = document.querySelector(`#bookmarks-tbody tr[data-title]`)?.closest('tbody')
				?.querySelector(`tr:has([data-bookmark-id="${data.id}"])`) 
				|| document.querySelector(`#bookmarks-tbody tr`)?.closest('tbody')
				?.querySelector(`tr`);
			
			// Alternative: find by iterating through rows
			const rows = document.querySelectorAll('#bookmarks-tbody tr');
			let targetRow = null;
			for (const r of rows) {
				// Check if this row contains an element with matching bookmark id
				const dropdown = r.querySelector(`[data-bookmark-id="${data.id}"]`);
				const titleEdit = r.querySelector(`[hx-get*="/admin/bookmarks/${data.id}/"]`);
				const publicBtn = r.querySelector(`[hx-post*="/admin/bookmarks/${data.id}/"]`);
				if (dropdown || titleEdit || publicBtn) {
					targetRow = r;
					break;
				}
			}

			if (!targetRow) return;

			// Update the relevant data attributes
			if ('title' in data) {
				targetRow.dataset.title = data.title;
			}
			if ('collectionId' in data) {
				targetRow.dataset.collectionId = data.collectionId;
			}
			if ('isPublic' in data) {
				targetRow.dataset.isPublic = String(data.isPublic);
			}
			if ('isFavorite' in data) {
				targetRow.dataset.isFavorite = String(data.isFavorite);
			}

			// Re-run filter to update visibility based on new data
			bookmarksFilter.apply();
		});
	</script>
}

// bookmarkCollectionFilter renders the collection filter dropdown with dynamic options
templ bookmarkCollectionFilter(collections []models.Collection) {
	<div data-dropdown class="dropdown">
		<input type="hidden" id="collection-filter" value=""/>
		<button type="button" data-dropdown-trigger class="dropdown-trigger" aria-expanded="false">
			<span data-dropdown-label>All Collections</span>
			@components.ChevronDownIcon(components.IconSM)
		</button>
		<div data-dropdown-menu class="dropdown-menu hidden">
			<button type="button" data-dropdown-option data-value="" class="dropdown-option" data-selected="true">All Collections</button>
			<button type="button" data-dropdown-option data-value="none" class="dropdown-option">Unsorted</button>
			for _, collection := range collections {
				<button type="button" data-dropdown-option data-value={ strconv.FormatInt(collection.ID, 10) } class="dropdown-option">
					{ collection.Name }
				</button>
			}
		</div>
	</div>
}

// Helper functions
func getCollectionID(bookmark models.Bookmark) string {
	if bookmark.CollectionID.Valid {
		return strconv.FormatInt(bookmark.CollectionID.Int64, 10)
	}
	return ""
}

func getFirstLetter(s string) string {
	for _, r := range s {
		return string(r)
	}
	return "?"
}

func getCollectionName(id int64, collections []models.Collection) string {
	for _, c := range collections {
		if c.ID == id {
			return c.Name
		}
	}
	return "Unknown"
}

func truncateURL(url string, maxLen int) string {
	if len(url) <= maxLen {
		return url
	}
	return url[:maxLen-3] + "..."
}

templ BookmarkForm(bookmark *models.Bookmark, collections []models.Collection, allTags []models.Tag, isNew bool) {
	@layouts.Admin(bookmarkFormTitle(bookmark, isNew)) {
		<div class="max-w-2xl space-y-6">
			<div>
				<h1 class="text-2xl font-bold tracking-tight text-foreground">
					if isNew {
						New Bookmark
					} else {
						Edit Bookmark
					}
				</h1>
				<p class="text-muted-foreground">
					if isNew {
						Save a new link to your collection.
					} else {
						Update bookmark details.
					}
				</p>
			</div>
			<form
				if isNew {
					action="/admin/bookmarks"
				} else {
					action={ templ.URL("/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10)) }
				}
				method="POST"
				class="space-y-6"
			>
				<input type="hidden" name="csrf_token" value={ getBookmarkCSRFToken(ctx) }/>
				<div class="card">
					<div class="card-content pt-6 space-y-6">
						<div class="space-y-2">
							<label for="url" class="label">URL</label>
							<input
								type="url"
								id="url"
								name="url"
								class="input"
								value={ bookmarkValue(bookmark, "url") }
								placeholder="https://example.com"
								required
								if isNew {
									hx-post="/admin/bookmarks/fetch-metadata"
									hx-trigger="blur"
									hx-include="this"
									hx-target="#metadata-fields"
									hx-swap="innerHTML"
									hx-indicator="#metadata-loading"
								}
							/>
						</div>
						<div id="metadata-loading" class="htmx-indicator text-sm text-muted-foreground py-2">
							Fetching page metadata...
						</div>
						<div id="metadata-fields">
							@BookmarkMetadataFields(bookmark)
						</div>
						<div class="space-y-2">
							<label for="collection_id" class="label">Collection</label>
							<select id="collection_id" name="collection_id" class="input">
								<option value="">No collection</option>
								for _, collection := range collections {
									<option
										value={ strconv.FormatInt(collection.ID, 10) }
										if bookmark != nil && bookmark.CollectionID.Valid && bookmark.CollectionID.Int64 == collection.ID {
											selected
										}
									>
										{ collection.Name }
									</option>
								}
							</select>
						</div>
						<div class="flex items-center gap-6">
							<div class="flex items-center space-x-2">
								<input
									type="checkbox"
									id="is_public"
									name="is_public"
									value="true"
									if bookmark == nil || bookmark.IsPublic {
										checked
									}
									class="h-4 w-4 rounded border-input text-primary focus:ring-ring"
								/>
								<label for="is_public" class="label">
									Public
								</label>
							</div>
							<div class="flex items-center space-x-2">
								<input
									type="checkbox"
									id="is_favorite"
									name="is_favorite"
									value="true"
									if bookmark != nil && bookmark.IsFavorite {
										checked
									}
									class="h-4 w-4 rounded border-input text-primary focus:ring-ring"
								/>
								<label for="is_favorite" class="label">
									Favorite
								</label>
							</div>
						</div>
					</div>
				</div>
				<div class="flex items-center gap-4">
					<button type="submit" class="btn-default">
						if isNew {
							Add Bookmark
						} else {
							Save Changes
						}
					</button>
					<a href="/admin/bookmarks" class="btn-outline">
						Cancel
					</a>
					if !isNew {
						<button
							type="button"
							hx-delete={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
							hx-confirm="Are you sure you want to delete this bookmark?"
							class="btn-destructive ml-auto"
						>
							Delete
						</button>
					}
				</div>
			</form>
		</div>
	}
}

templ BookmarkMetadataFields(bookmark *models.Bookmark) {
	<div class="space-y-6">
		<div class="space-y-2">
			<label for="title" class="label">Title</label>
			<input
				type="text"
				id="title"
				name="title"
				class="input"
				value={ bookmarkValue(bookmark, "title") }
				placeholder="Page title"
				required
			/>
		</div>
		<div class="space-y-2">
			<label for="description" class="label">Description</label>
			<textarea
				id="description"
				name="description"
				rows="3"
				class="textarea"
				placeholder="Brief description"
			>{ bookmarkValue(bookmark, "description") }</textarea>
		</div>
		<div class="space-y-2">
			<label for="cover_image" class="label">Cover Image URL</label>
			<input
				type="url"
				id="cover_image"
				name="cover_image"
				class="input"
				value={ bookmarkValue(bookmark, "cover_image") }
				placeholder="https://example.com/image.jpg"
			/>
		</div>
	</div>
}

func bookmarkFormTitle(bookmark *models.Bookmark, isNew bool) string {
	if isNew {
		return "New Bookmark"
	}
	return "Edit: " + bookmark.Title
}

func bookmarkValue(bookmark *models.Bookmark, field string) string {
	if bookmark == nil {
		return ""
	}
	switch field {
	case "url":
		return bookmark.URL
	case "title":
		return bookmark.Title
	case "description":
		return bookmark.GetDescription()
	case "cover_image":
		return bookmark.GetCoverImage()
	}
	return ""
}

// ============================================
// INLINE EDIT PARTIALS (for HTMX responses)
// ============================================

// BookmarkPublicBadge renders the public/private toggle badge
templ BookmarkPublicBadge(id int64, isPublic bool, success bool) {
	if isPublic {
		<button
			type="button"
			hx-post={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-public" }
			hx-swap="outerHTML"
			class={ "badge-success cursor-pointer hover:bg-green-100", templ.KV("save-success", success) }
			title="Click to make private"
		>
			@components.GlobeIcon(components.IconXS)
			Public
		</button>
	} else {
		<button
			type="button"
			hx-post={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-public" }
			hx-swap="outerHTML"
			class={ "badge-muted cursor-pointer hover:bg-muted/80", templ.KV("save-success", success) }
			title="Click to make public"
		>
			@components.LockIcon(components.IconXS)
			Private
		</button>
	}
}

// BookmarkFavoriteStar renders the favorite toggle star
templ BookmarkFavoriteStar(id int64, isFavorite bool, success bool) {
	if isFavorite {
		<button
			type="button"
			hx-post={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-favorite" }
			hx-swap="outerHTML"
			class={ "text-amber-500 cursor-pointer hover:text-amber-600", templ.KV("save-success", success) }
			title="Remove from favorites"
		>
			@components.StarFilledIcon(components.IconSM)
		</button>
	} else {
		<button
			type="button"
			hx-post={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-favorite" }
			hx-swap="outerHTML"
			class={ "text-muted-foreground/40 cursor-pointer hover:text-amber-500", templ.KV("save-success", success) }
			title="Add to favorites"
		>
			@components.StarIcon(components.IconSM)
		</button>
	}
}

// BookmarkCollectionDropdown renders the inline collection selector
templ BookmarkCollectionDropdown(id int64, currentCollectionID int64, hasCollection bool, collections []models.Collection, success bool) {
	<div
		data-dropdown
		class={ "dropdown w-28", templ.KV("save-success", success) }
		data-bookmark-id={ strconv.FormatInt(id, 10) }
	>
		<input type="hidden" id={ "collection-" + strconv.FormatInt(id, 10) } value={ getCurrentCollectionValue(currentCollectionID, hasCollection) }/>
		<button type="button" data-dropdown-trigger class="dropdown-trigger h-6 text-[10px]" aria-expanded="false">
			<span data-dropdown-label class="truncate">{ getCurrentCollectionLabel(currentCollectionID, hasCollection, collections) }</span>
			@components.ChevronDownIcon(components.IconSM)
		</button>
		<div data-dropdown-menu class="dropdown-menu hidden">
			<button
				type="button"
				data-dropdown-option
				data-value=""
				class="dropdown-option"
				hx-post={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/collection" }
				hx-vals='{"collection_id": ""}'
				hx-target="closest [data-dropdown]"
				hx-swap="outerHTML"
				if !hasCollection {
					data-selected="true"
				}
			>
				—
			</button>
			for _, collection := range collections {
				<button
					type="button"
					data-dropdown-option
					data-value={ strconv.FormatInt(collection.ID, 10) }
					class="dropdown-option"
					hx-post={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/collection" }
					hx-vals={ `{"collection_id": "` + strconv.FormatInt(collection.ID, 10) + `"}` }
					hx-target="closest [data-dropdown]"
					hx-swap="outerHTML"
					if hasCollection && currentCollectionID == collection.ID {
						data-selected="true"
					}
				>
					{ collection.Name }
				</button>
			}
		</div>
	</div>
}

// BookmarkTitleDisplay renders the clickable title (display mode)
templ BookmarkTitleDisplay(id int64, title string, url string, success bool) {
	<div class={ "min-w-0 flex-1", templ.KV("save-success", success) }>
		<span
			class="font-medium text-foreground block truncate inline-editable"
			tabindex="0"
			hx-get={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/edit-title" }
			hx-trigger="click, keydown[key=='Enter']"
			hx-swap="outerHTML"
			hx-target="closest div"
			title={ "Click to edit: " + title }
		>
			{ title }
		</span>
		<a
			href={ templ.URL(url) }
			target="_blank"
			class="text-[11px] text-muted-foreground hover:underline truncate block"
			title={ url }
		>
			{ truncateURL(url, 50) }
		</a>
	</div>
}

// BookmarkTitleEdit renders the input field (edit mode)
templ BookmarkTitleEdit(id int64, title string, url string) {
	<div class="min-w-0 flex-1">
		<input
			type="text"
			value={ title }
			class="inline-edit-input w-full"
			hx-post={ "/admin/bookmarks/" + strconv.FormatInt(id, 10) + "/title" }
			hx-trigger="blur, keyup[key=='Enter']"
			hx-swap="outerHTML"
			hx-target="closest div"
			name="title"
			autofocus
		/>
		<a
			href={ templ.URL(url) }
			target="_blank"
			class="text-[11px] text-muted-foreground hover:underline truncate block"
			title={ url }
		>
			{ truncateURL(url, 50) }
		</a>
	</div>
}

// Helper functions for collection dropdown
func getCurrentCollectionValue(collectionID int64, hasCollection bool) string {
	if hasCollection {
		return strconv.FormatInt(collectionID, 10)
	}
	return ""
}

func getCurrentCollectionLabel(collectionID int64, hasCollection bool, collections []models.Collection) string {
	if !hasCollection {
		return "—"
	}
	for _, c := range collections {
		if c.ID == collectionID {
			return c.Name
		}
	}
	return "—"
}
