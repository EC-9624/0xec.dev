package admin

import (
	"context"
	"strconv"

	"github.com/EC-9624/0xec.dev/internal/middleware"
	"github.com/EC-9624/0xec.dev/internal/models"
	"github.com/EC-9624/0xec.dev/web/templates/components"
	"github.com/EC-9624/0xec.dev/web/templates/layouts"
)

// getCSRFToken retrieves the CSRF token from context
func getBookmarkCSRFToken(ctx context.Context) string {
	token, ok := ctx.Value(middleware.CSRFTokenContextKey).(string)
	if !ok {
		return ""
	}
	return token
}

// BookmarksListData contains data for the bookmarks list page
type BookmarksListData struct {
	Bookmarks               []models.Bookmark
	Collections             []models.Collection
	PreselectedCollectionID int64 // 0 means no preselection
}

templ BookmarksList(data BookmarksListData) {
	@layouts.Admin("Bookmarks") {
		<div class="space-y-4">
			<!-- Header -->
			@components.PageHeader("Bookmarks", strconv.Itoa(len(data.Bookmarks))+" bookmarks") {
				@components.RefreshButton("refresh-btn", "startMetadataRefresh()", "Refresh Metadata")
				@components.ImportButton("/admin/import")
				@components.NewButtonDrawer("/admin/htmx/bookmarks/new-drawer", "New Bookmark", "New Bookmark")
			}
			<!-- Refresh Progress Banner (hidden by default) -->
			<div id="refresh-progress" class="hidden">
				<div class="bg-muted border border-border p-4 space-y-2">
					<div class="flex items-center justify-between">
						<span id="refresh-status" class="text-sm font-medium">Preparing...</span>
						<span id="refresh-count" class="text-sm text-muted-foreground"></span>
					</div>
					<div class="w-full bg-border h-2">
						<div id="refresh-bar" class="bg-primary h-2 transition-all duration-300 w-0"></div>
					</div>
					<p id="refresh-current" class="text-xs text-muted-foreground truncate"></p>
				</div>
			</div>
			<!-- Filters Bar -->
			@components.FilterBar(components.FilterBarProps{}) {
				@components.SearchInput(components.SearchInputProps{
					ID:          "bookmark-search",
					Placeholder: "Search bookmarks...",
					OnInput:     "bookmarksFilter.apply()",
				})
				<!-- Collection Filter (custom with dynamic options) -->
				@bookmarkCollectionFilter(data.Collections, data.PreselectedCollectionID)
				@components.FilterDropdown(components.FilterDropdownProps{
					ID:           "status-filter",
					DefaultLabel: "All Status",
					Options:      components.BookmarkStatusOptions(),
					OnChange:     "bookmarksFilter.apply()",
				})
				@components.ClearFiltersButton("bookmarksFilter.clear()")
			}
			<!-- Table -->
			if len(data.Bookmarks) > 0 {
				<div class="card">
					<table class="table" id="bookmarks-table">
						<thead class="table-header bg-muted/50">
							<tr class="table-row">
								<th class="table-head w-[50%]">Title</th>
								<th class="table-head w-[20%]">Collection</th>
								<th class="table-head w-[15%]">Status</th>
								<th class="table-head w-[15%] text-right">Actions</th>
							</tr>
						</thead>
						<tbody class="table-body" id="bookmarks-tbody">
							for _, bookmark := range data.Bookmarks {
								@bookmarkRow(bookmark, data.Collections)
							}
						</tbody>
					</table>
				</div>
				<!-- No results message (hidden by default) -->
				@components.NoResults("bookmarks", "bookmarksFilter.clear")
			} else {
				@components.EmptyState(components.EmptyStateProps{
					Icon:        components.BookmarkIcon(components.IconXXL),
					Title:       "No bookmarks yet",
					Description: "Start saving interesting links.",
					CTAHref:     "/admin/bookmarks/new",
					CTAText:     "Add your first bookmark",
				})
			}
		</div>
		<!-- Client-side filtering script -->
		@bookmarksFilterScript()
	}
}

templ bookmarkRow(bookmark models.Bookmark, collections []models.Collection) {
	<tr
		id={ "bookmark-row-" + strconv.FormatInt(bookmark.ID, 10) }
		class="table-row group"
		data-title={ bookmark.Title }
		data-url={ bookmark.URL }
		data-domain={ bookmark.GetDomain() }
		data-collection-id={ getCollectionID(bookmark) }
		data-is-public={ strconv.FormatBool(bookmark.IsPublic) }
		data-is-favorite={ strconv.FormatBool(bookmark.IsFavorite) }
	>
		<!-- Title -->
		<td class="table-cell overflow-hidden">
			<div class="flex items-center gap-2 min-w-0">
				<!-- Favicon -->
				<div class="w-6 h-6 bg-muted flex items-center justify-center text-xs text-muted-foreground shrink-0 overflow-hidden">
					<img
						src={ bookmark.GetFaviconURL() }
						alt=""
						class="w-4 h-4 object-contain"
						loading="lazy"
						onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"
					/>
					<span class="hidden items-center justify-center w-full h-full text-[10px]">{ getFirstLetter(bookmark.GetDomain()) }</span>
				</div>
				<div class="min-w-0 flex-1">
					<button
						type="button"
						hx-get={ "/admin/htmx/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) + "/edit-drawer" }
						hx-target="#drawer-content"
						hx-swap="innerHTML"
						onclick="window.drawerOpen('Edit Bookmark')"
						class="font-medium text-foreground hover:underline block truncate text-left cursor-pointer"
						title={ bookmark.Title }
					>
						{ bookmark.Title }
					</button>
					<a
						href={ templ.URL(bookmark.URL) }
						target="_blank"
						class="text-[11px] text-muted-foreground hover:underline truncate block"
						title={ bookmark.URL }
					>
						{ truncateURL(bookmark.URL, 50) }
					</a>
				</div>
			</div>
		</td>
		<!-- Collection (inline dropdown) -->
		<td class="table-cell">
			@BookmarkCollectionDropdown(bookmark.ID, bookmark.CollectionID.Int64, bookmark.CollectionID.Valid, collections, false)
		</td>
		<!-- Status (inline toggles) -->
		<td class="table-cell">
			<div class="flex items-center gap-1">
				@BookmarkPublicBadge(bookmark.ID, bookmark.IsPublic, false)
				@BookmarkFavoriteStar(bookmark.ID, bookmark.IsFavorite, false)
			</div>
		</td>
		<!-- Actions -->
		<td class="table-cell text-right">
			<div class="row-actions">
				<a
					href={ templ.URL(bookmark.URL) }
					class="btn-ghost btn-xs"
					target="_blank"
					title="Open link"
				>
					@components.ExternalLinkIcon(components.IconMD)
				</a>
				<a
					href={ templ.URL("/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) + "/edit") }
					class="btn-ghost btn-xs"
					title="Full edit"
				>
					@components.EditIcon(components.IconMD)
				</a>
				<button
					type="button"
					hx-delete={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
					hx-confirm="Delete this bookmark?"
					hx-target="closest tr"
					hx-swap="outerHTML swap:0.2s"
					class="btn-ghost btn-xs text-destructive hover:text-destructive"
					title="Delete"
				>
					@components.TrashIcon(components.IconMD)
				</button>
			</div>
		</td>
	</tr>
}

templ bookmarksFilterScript() {
	<script>
		// Initialize table filter using the reusable TableFilter class
		const bookmarksFilter = new TableFilter({
			tableBodyId: 'bookmarks-tbody',
			searchId: 'bookmark-search',
			filters: [
				{ id: 'collection-filter', match: TableFilter.collectionMatcher },
				{ id: 'status-filter', match: TableFilter.bookmarkStatusMatcher }
			],
			searchFields: ['title', 'url', 'domain'],
			storageKey: 'bookmarkFilters',
			tableCardSelector: '.card:has(#bookmarks-table)'
		});

		// Initialize on DOM ready
		document.addEventListener('DOMContentLoaded', () => {
			bookmarksFilter.init();
			// Apply preselected collection filter if set
			const collectionFilter = document.getElementById('collection-filter');
			if (collectionFilter && collectionFilter.value) {
				bookmarksFilter.apply();
			}
		});

		// Metadata refresh with SSE progress
		function startMetadataRefresh() {
			const btn = document.getElementById('refresh-btn');
			const btnText = document.getElementById('refresh-btn-text');
			const progress = document.getElementById('refresh-progress');
			const status = document.getElementById('refresh-status');
			const count = document.getElementById('refresh-count');
			const bar = document.getElementById('refresh-bar');
			const current = document.getElementById('refresh-current');

			// Disable button and show progress
			btn.disabled = true;
			btn.classList.add('opacity-50');
			btnText.textContent = 'Refreshing...';
			progress.classList.remove('hidden');
			status.textContent = 'Connecting...';
			bar.style.width = '0%';

			const eventSource = new EventSource('/admin/htmx/bookmarks/refresh-all');

			eventSource.onmessage = (event) => {
				const parts = event.data.split(':');
				const type = parts[0];

				if (type === 'start') {
					const total = parts[1];
					status.textContent = 'Refreshing metadata...';
					count.textContent = `0 / ${total}`;
				} else if (type === 'progress') {
					const current_num = parseInt(parts[1]);
					const total = parseInt(parts[2]);
					const title = parts.slice(3).join(':'); // Title might contain colons
					const pct = Math.round((current_num / total) * 100);
					bar.style.width = pct + '%';
					count.textContent = `${current_num} / ${total}`;
					current.textContent = `Processing: ${title}`;
				} else if (type === 'done') {
					const updated = parts[1];
					const failed = parts[2];
					eventSource.close();
					
					status.textContent = 'Completed!';
					bar.style.width = '100%';
					current.textContent = `Updated: ${updated}, Failed: ${failed}`;
					count.textContent = '';
					
					// Re-enable button
					btn.disabled = false;
					btn.classList.remove('opacity-50');
					btnText.textContent = 'Refresh Metadata';

					// Hide progress after 3 seconds and reload
					setTimeout(() => {
						progress.classList.add('hidden');
						window.location.reload();
					}, 2000);
				} else if (type === 'error') {
					eventSource.close();
					status.textContent = 'Error: ' + parts.slice(1).join(':');
					bar.style.width = '0%';
					btn.disabled = false;
					btn.classList.remove('opacity-50');
					btnText.textContent = 'Refresh Metadata';
				}
			};

			eventSource.onerror = () => {
				eventSource.close();
				status.textContent = 'Connection error';
				btn.disabled = false;
				btn.classList.remove('opacity-50');
				btnText.textContent = 'Refresh Metadata';
			};
		}

		// Listen for HX-Trigger events to update row data attributes for filtering
		document.body.addEventListener('updateRowData', (e) => {
			const data = e.detail;
			if (!data || !data.id) return;

			// Find the row by looking for any element with data-bookmark-id or the tr itself
			const row = document.querySelector(`#bookmarks-tbody tr[data-title]`)?.closest('tbody')
				?.querySelector(`tr:has([data-bookmark-id="${data.id}"])`) 
				|| document.querySelector(`#bookmarks-tbody tr`)?.closest('tbody')
				?.querySelector(`tr`);
			
			// Alternative: find by iterating through rows
			const rows = document.querySelectorAll('#bookmarks-tbody tr');
			let targetRow = null;
			for (const r of rows) {
				// Check if this row contains an element with matching bookmark id
				const dropdown = r.querySelector(`[data-bookmark-id="${data.id}"]`);
				const titleEdit = r.querySelector(`[hx-get*="/admin/htmx/bookmarks/${data.id}/"]`);
				const publicBtn = r.querySelector(`[hx-post*="/admin/htmx/bookmarks/${data.id}/"]`);
				if (dropdown || titleEdit || publicBtn) {
					targetRow = r;
					break;
				}
			}

			if (!targetRow) return;

			// Update the relevant data attributes
			if ('title' in data) {
				targetRow.dataset.title = data.title;
			}
			if ('collectionId' in data) {
				targetRow.dataset.collectionId = data.collectionId;
			}
			if ('isPublic' in data) {
				targetRow.dataset.isPublic = String(data.isPublic);
			}
			if ('isFavorite' in data) {
				targetRow.dataset.isFavorite = String(data.isFavorite);
			}

			// Re-run filter to update visibility based on new data
			bookmarksFilter.apply();
		});
	</script>
}

// bookmarkCollectionFilter renders the collection filter dropdown with dynamic options
templ bookmarkCollectionFilter(collections []models.Collection, preselectedID int64) {
	<div data-dropdown class="dropdown">
		<input type="hidden" id="collection-filter" value={ preselectedCollectionValue(preselectedID) }/>
		<button type="button" data-dropdown-trigger class="dropdown-trigger" aria-expanded="false">
			<span data-dropdown-label>{ preselectedCollectionLabel(collections, preselectedID) }</span>
			@components.ChevronDownIcon(components.IconSM)
		</button>
		<div data-dropdown-menu class="dropdown-menu hidden">
			<button type="button" data-dropdown-option data-value="" class="dropdown-option" data-selected={ boolStr(preselectedID == 0) }>All Collections</button>
			<button type="button" data-dropdown-option data-value="none" class="dropdown-option">Unsorted</button>
			for _, collection := range collections {
				<button type="button" data-dropdown-option data-value={ strconv.FormatInt(collection.ID, 10) } class="dropdown-option" data-selected={ boolStr(collection.ID == preselectedID) }>
					{ collection.Name }
				</button>
			}
		</div>
	</div>
}

// preselectedCollectionValue returns the filter value for preselection
func preselectedCollectionValue(id int64) string {
	if id == 0 {
		return ""
	}
	return strconv.FormatInt(id, 10)
}

// preselectedCollectionLabel returns the label for the preselected collection
func preselectedCollectionLabel(collections []models.Collection, id int64) string {
	if id == 0 {
		return "All Collections"
	}
	for _, c := range collections {
		if c.ID == id {
			return c.Name
		}
	}
	return "All Collections"
}

// boolStr returns "true" or "false" as string
func boolStr(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

// Helper functions
func getCollectionID(bookmark models.Bookmark) string {
	if bookmark.CollectionID.Valid {
		return strconv.FormatInt(bookmark.CollectionID.Int64, 10)
	}
	return ""
}

func getFirstLetter(s string) string {
	for _, r := range s {
		return string(r)
	}
	return "?"
}

func getCollectionName(id int64, collections []models.Collection) string {
	for _, c := range collections {
		if c.ID == id {
			return c.Name
		}
	}
	return "Unknown"
}

func truncateURL(url string, maxLen int) string {
	if len(url) <= maxLen {
		return url
	}
	return url[:maxLen-3] + "..."
}

templ BookmarkForm(bookmark *models.Bookmark, collections []models.Collection, isNew bool, errors *models.FormErrors, input *models.CreateBookmarkInput) {
	@layouts.Admin(bookmarkFormTitle(bookmark, isNew)) {
		<div class="max-w-2xl space-y-6">
			<div>
				<h1 class="text-2xl font-bold tracking-tight text-foreground">
					if isNew {
						New Bookmark
					} else {
						Edit Bookmark
					}
				</h1>
				<p class="text-muted-foreground">
					if isNew {
						Save a new link to your collection.
					} else {
						Update bookmark details.
					}
				</p>
			</div>
			@components.FormErrorBanner(errors)
			<form
				if isNew {
					action="/admin/bookmarks"
				} else {
					action={ templ.URL("/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10)) }
				}
				method="POST"
				class="space-y-6"
				data-validate
				novalidate
			>
				<input type="hidden" name="csrf_token" value={ getBookmarkCSRFToken(ctx) }/>
				<div class="card">
					<div class="card-content pt-6 space-y-6">
						<div class="space-y-2">
							<label for="url" class="label">URL <span class="text-destructive">*</span></label>
							<input
								type="url"
								id="url"
								name="url"
								class={ components.InputClass(errors, "url") }
								value={ bookmarkFormValue(bookmark, input, "url") }
								placeholder="https://example.com"
								required
								data-error-required="URL is required"
								data-error-url="URL must be a valid HTTP or HTTPS URL"
								if isNew {
									hx-post="/admin/htmx/bookmarks/fetch-metadata"
									hx-trigger="blur"
									hx-include="this"
									hx-target="#metadata-fields"
									hx-swap="innerHTML"
									hx-indicator="#metadata-loading"
								}
							/>
							@components.FieldError(errors, "url")
						</div>
						<div id="metadata-loading" class="htmx-indicator text-muted-foreground py-2">
							@components.SpinnerIcon(components.IconSM)
						</div>
						<div id="metadata-fields">
							@BookmarkMetadataFieldsWithErrors(bookmark, errors, input)
						</div>
						<div class="space-y-2">
							<label class="label">Collection</label>
							@components.FormSelect(components.FormSelectProps{
								ID:          "collection_id",
								Options:     collectionsToFormOptions(collections),
								Selected:    getSelectedCollectionValue(bookmark, input),
								Placeholder: "No collection",
							})
						</div>
						<div class="flex items-center gap-6">
							<div class="flex items-center space-x-2">
								<input
									type="checkbox"
									id="is_public"
									name="is_public"
									value="true"
									if bookmarkFormIsPublic(bookmark, input) {
										checked
									}
									class="h-4 w-4 rounded border-input text-primary focus:ring-ring"
								/>
								<label for="is_public" class="label">
									Public
								</label>
							</div>
							<div class="flex items-center space-x-2">
								<input
									type="checkbox"
									id="is_favorite"
									name="is_favorite"
									value="true"
									if bookmarkFormIsFavorite(bookmark, input) {
										checked
									}
									class="h-4 w-4 rounded border-input text-primary focus:ring-ring"
								/>
								<label for="is_favorite" class="label">
									Favorite
								</label>
							</div>
						</div>
					</div>
				</div>
				<div class="flex items-center gap-4">
					<button type="submit" class="btn-default">
						if isNew {
							Add Bookmark
						} else {
							Save Changes
						}
					</button>
					<a href="/admin/bookmarks" class="btn-outline">
						Cancel
					</a>
					if !isNew {
						<button
							type="button"
							hx-delete={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
							hx-confirm="Are you sure you want to delete this bookmark?"
							class="btn-destructive ml-auto"
						>
							Delete
						</button>
					}
				</div>
			</form>
		</div>
	}
}

templ BookmarkMetadataFields(bookmark *models.Bookmark) {
	@BookmarkMetadataFieldsWithErrors(bookmark, nil, nil)
}

templ BookmarkMetadataFieldsWithErrors(bookmark *models.Bookmark, errors *models.FormErrors, input *models.CreateBookmarkInput) {
	<div class="space-y-6">
		<div class="space-y-2">
			<label for="title" class="label">Title <span class="text-destructive">*</span></label>
			<input
				type="text"
				id="title"
				name="title"
				class={ components.InputClass(errors, "title") }
				value={ bookmarkFormValue(bookmark, input, "title") }
				placeholder="Page title"
				required
				maxlength="200"
				data-error-required="Title is required"
				data-error-maxlength="Title cannot exceed 200 characters"
			/>
			@components.FieldError(errors, "title")
		</div>
		<div class="space-y-2">
			<label for="description" class="label">Description</label>
			<textarea
				id="description"
				name="description"
				rows="3"
				class={ components.TextareaClass(errors, "description") }
				placeholder="Brief description"
				maxlength="500"
				data-error-maxlength="Description cannot exceed 500 characters"
			>{ bookmarkFormValue(bookmark, input, "description") }</textarea>
			@components.FieldError(errors, "description")
		</div>
		<div class="space-y-2">
			<label for="cover_image" class="label">Cover Image URL</label>
			<input
				type="url"
				id="cover_image"
				name="cover_image"
				class={ components.InputClass(errors, "cover_image") }
				value={ bookmarkFormValue(bookmark, input, "cover_image") }
				placeholder="https://example.com/image.jpg"
				data-error-url="Cover image must be a valid URL"
			/>
			@components.FieldError(errors, "cover_image")
		</div>
	</div>
}

func bookmarkFormTitle(bookmark *models.Bookmark, isNew bool) string {
	if isNew {
		return "New Bookmark"
	}
	return "Edit: " + bookmark.Title
}

func bookmarkValue(bookmark *models.Bookmark, field string) string {
	if bookmark == nil {
		return ""
	}
	switch field {
	case "url":
		return bookmark.URL
	case "title":
		return bookmark.Title
	case "description":
		return bookmark.GetDescription()
	case "cover_image":
		return bookmark.GetCoverImage()
	}
	return ""
}

// bookmarkFormValue returns the value for a form field, preferring input over bookmark
// This preserves user input on validation errors
func bookmarkFormValue(bookmark *models.Bookmark, input *models.CreateBookmarkInput, field string) string {
	// If we have input (from a failed submission), use that
	if input != nil {
		switch field {
		case "url":
			return input.URL
		case "title":
			return input.Title
		case "description":
			return input.Description
		case "cover_image":
			return input.CoverImage
		}
	}
	// Otherwise use the bookmark data
	return bookmarkValue(bookmark, field)
}

// bookmarkFormCollectionSelected returns whether a collection option should be selected
func bookmarkFormCollectionSelected(bookmark *models.Bookmark, input *models.CreateBookmarkInput, collectionID int64) bool {
	if input != nil && input.CollectionID != nil {
		return *input.CollectionID == collectionID
	}
	if bookmark != nil && bookmark.CollectionID.Valid {
		return bookmark.CollectionID.Int64 == collectionID
	}
	return false
}

// bookmarkFormIsPublic returns whether the public checkbox should be checked
func bookmarkFormIsPublic(bookmark *models.Bookmark, input *models.CreateBookmarkInput) bool {
	if input != nil {
		return input.IsPublic
	}
	if bookmark != nil {
		return bookmark.IsPublic
	}
	return true // Default to public for new bookmarks
}

// bookmarkFormIsFavorite returns whether the favorite checkbox should be checked
func bookmarkFormIsFavorite(bookmark *models.Bookmark, input *models.CreateBookmarkInput) bool {
	if input != nil {
		return input.IsFavorite
	}
	if bookmark != nil {
		return bookmark.IsFavorite
	}
	return false // Default to not favorite for new bookmarks
}

// collectionsToFormOptions converts collections to FormSelect options
func collectionsToFormOptions(collections []models.Collection) []components.FormSelectOption {
	opts := make([]components.FormSelectOption, len(collections))
	for i, c := range collections {
		opts[i] = components.FormSelectOption{
			Value: strconv.FormatInt(c.ID, 10),
			Label: c.Name,
		}
	}
	return opts
}

// getSelectedCollectionValue returns the selected collection ID as string for form select
func getSelectedCollectionValue(bookmark *models.Bookmark, input *models.CreateBookmarkInput) string {
	if input != nil && input.CollectionID != nil {
		return strconv.FormatInt(*input.CollectionID, 10)
	}
	if bookmark != nil && bookmark.CollectionID.Valid {
		return strconv.FormatInt(bookmark.CollectionID.Int64, 10)
	}
	return ""
}

// ============================================
// INLINE EDIT PARTIALS (for HTMX responses)
// ============================================

// BookmarkPublicBadge renders the public/private toggle badge
templ BookmarkPublicBadge(id int64, isPublic bool, success bool) {
	if isPublic {
		<button
			type="button"
			hx-post={ "/admin/htmx/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-public" }
			hx-swap="outerHTML"
			class={ "badge-success cursor-pointer hover:bg-green-100", templ.KV("save-success", success) }
			title="Click to make private"
		>
			@components.GlobeIcon(components.IconXS)
			Public
		</button>
	} else {
		<button
			type="button"
			hx-post={ "/admin/htmx/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-public" }
			hx-swap="outerHTML"
			class={ "badge-muted cursor-pointer hover:bg-muted/80", templ.KV("save-success", success) }
			title="Click to make public"
		>
			@components.LockIcon(components.IconXS)
			Private
		</button>
	}
}

// BookmarkFavoriteStar renders the favorite toggle star
templ BookmarkFavoriteStar(id int64, isFavorite bool, success bool) {
	if isFavorite {
		<button
			type="button"
			hx-post={ "/admin/htmx/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-favorite" }
			hx-swap="outerHTML"
			class={ "text-amber-500 cursor-pointer hover:text-amber-600", templ.KV("save-success", success) }
			title="Remove from favorites"
		>
			@components.StarFilledIcon(components.IconSM)
		</button>
	} else {
		<button
			type="button"
			hx-post={ "/admin/htmx/bookmarks/" + strconv.FormatInt(id, 10) + "/toggle-favorite" }
			hx-swap="outerHTML"
			class={ "text-muted-foreground/40 cursor-pointer hover:text-amber-500", templ.KV("save-success", success) }
			title="Add to favorites"
		>
			@components.StarIcon(components.IconSM)
		</button>
	}
}

// BookmarkCollectionDropdown renders the inline collection selector
templ BookmarkCollectionDropdown(id int64, currentCollectionID int64, hasCollection bool, collections []models.Collection, success bool) {
	<div
		data-dropdown
		class={ "dropdown w-28", templ.KV("save-success", success) }
		data-bookmark-id={ strconv.FormatInt(id, 10) }
	>
		<input type="hidden" id={ "collection-" + strconv.FormatInt(id, 10) } value={ getCurrentCollectionValue(currentCollectionID, hasCollection) }/>
		<button type="button" data-dropdown-trigger class="dropdown-trigger h-6 text-[10px]" aria-expanded="false">
			<span data-dropdown-label class="truncate">{ getCurrentCollectionLabel(currentCollectionID, hasCollection, collections) }</span>
			@components.ChevronDownIcon(components.IconSM)
		</button>
		<div data-dropdown-menu class="dropdown-menu hidden">
			<button
				type="button"
				data-dropdown-option
				data-value=""
				class="dropdown-option"
				hx-post={ "/admin/htmx/bookmarks/" + strconv.FormatInt(id, 10) + "/collection" }
				hx-vals='{"collection_id": ""}'
				hx-target="closest [data-dropdown]"
				hx-swap="outerHTML"
				if !hasCollection {
					data-selected="true"
				}
			>
				—
			</button>
			for _, collection := range collections {
				<button
					type="button"
					data-dropdown-option
					data-value={ strconv.FormatInt(collection.ID, 10) }
					class="dropdown-option"
					hx-post={ "/admin/htmx/bookmarks/" + strconv.FormatInt(id, 10) + "/collection" }
					hx-vals={ `{"collection_id": "` + strconv.FormatInt(collection.ID, 10) + `"}` }
					hx-target="closest [data-dropdown]"
					hx-swap="outerHTML"
					if hasCollection && currentCollectionID == collection.ID {
						data-selected="true"
					}
				>
					{ collection.Name }
				</button>
			}
		</div>
	</div>
}

// Helper functions for collection dropdown
func getCurrentCollectionValue(collectionID int64, hasCollection bool) string {
	if hasCollection {
		return strconv.FormatInt(collectionID, 10)
	}
	return ""
}

func getCurrentCollectionLabel(collectionID int64, hasCollection bool, collections []models.Collection) string {
	if !hasCollection {
		return "—"
	}
	for _, c := range collections {
		if c.ID == collectionID {
			return c.Name
		}
	}
	return "—"
}

// ============================================
// DRAWER FORM COMPONENTS
// ============================================

// BookmarkFormDrawer renders the bookmark form for use in a drawer
// It doesn't include the layout wrapper, just the form content
templ BookmarkFormDrawer(bookmark *models.Bookmark, collections []models.Collection, isNew bool, errors *models.FormErrors, input *models.CreateBookmarkInput) {
	<form
		if isNew {
			hx-post="/admin/bookmarks"
		} else {
			hx-post={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
		}
		hx-target="#drawer-content"
		hx-swap="innerHTML"
		class="flex flex-col h-full"
		data-validate
		novalidate
	>
		<input type="hidden" name="csrf_token" value={ getBookmarkCSRFToken(ctx) }/>
		<input type="hidden" name="_drawer" value="true"/>
		<!-- Scrollable form content -->
		<div class="drawer-form flex-1 overflow-y-auto">
			<p class="text-sm text-muted-foreground mb-6">
				if isNew {
					Save a new link to your collection.
				} else {
					Update bookmark details.
				}
			</p>
			@components.FormErrorBanner(errors)
			<!-- URL Field -->
			<div class="space-y-2 mb-6">
				<label for="url" class="label">URL <span class="text-destructive">*</span></label>
				<input
					type="url"
					id="url"
					name="url"
					class={ components.InputClass(errors, "url") }
					value={ bookmarkFormValue(bookmark, input, "url") }
					placeholder="https://example.com"
					required
					data-error-required="URL is required"
					data-error-url="URL must be a valid HTTP or HTTPS URL"
					if isNew {
						hx-post="/admin/htmx/bookmarks/fetch-metadata"
						hx-trigger="blur"
						hx-include="this"
						hx-target="#metadata-fields"
						hx-swap="innerHTML"
						hx-indicator="#metadata-loading"
					}
				/>
				@components.FieldError(errors, "url")
			</div>
			<div id="metadata-loading" class="htmx-indicator text-muted-foreground py-2">
				@components.SpinnerIcon(components.IconSM)
			</div>
			<div id="metadata-fields">
				@BookmarkMetadataFieldsWithErrors(bookmark, errors, input)
			</div>
			<!-- Collection -->
			<div class="space-y-2 mb-6">
				<label class="label">Collection</label>
				@components.FormSelect(components.FormSelectProps{
					ID:          "collection_id",
					Options:     collectionsToFormOptions(collections),
					Selected:    getSelectedCollectionValue(bookmark, input),
					Placeholder: "No collection",
				})
			</div>
			<!-- Checkboxes -->
			<div class="flex items-center gap-6">
				<div class="flex items-center space-x-2">
					<input
						type="checkbox"
						id="is_public"
						name="is_public"
						value="true"
						if bookmarkFormIsPublic(bookmark, input) {
							checked
						}
						class="h-4 w-4 rounded border-input text-primary focus:ring-ring"
					/>
					<label for="is_public" class="label">Public</label>
				</div>
				<div class="flex items-center space-x-2">
					<input
						type="checkbox"
						id="is_favorite"
						name="is_favorite"
						value="true"
						if bookmarkFormIsFavorite(bookmark, input) {
							checked
						}
						class="h-4 w-4 rounded border-input text-primary focus:ring-ring"
					/>
					<label for="is_favorite" class="label">Favorite</label>
				</div>
			</div>
		</div>
		<!-- Sticky footer actions -->
		<div class="drawer-form-actions">
			<button type="submit" class="btn-default">
				if isNew {
					Add Bookmark
				} else {
					Save Changes
				}
			</button>
			<button type="button" onclick="window.drawerClose()" class="btn-outline">
				Cancel
			</button>
			if !isNew {
				<button
					type="button"
					hx-delete={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
					hx-confirm="Delete this bookmark?"
					class="btn-destructive ml-auto"
				>
					Delete
				</button>
			}
		</div>
	</form>
}

// BookmarkRowOOB renders a bookmark row for out-of-band swap after update
templ BookmarkRowOOB(bookmark models.Bookmark, collections []models.Collection) {
	<tr
		id={ "bookmark-row-" + strconv.FormatInt(bookmark.ID, 10) }
		hx-swap-oob="true"
		class="table-row group"
		data-title={ bookmark.Title }
		data-url={ bookmark.URL }
		data-domain={ bookmark.GetDomain() }
		data-collection-id={ getCollectionID(bookmark) }
		data-is-public={ strconv.FormatBool(bookmark.IsPublic) }
		data-is-favorite={ strconv.FormatBool(bookmark.IsFavorite) }
	>
		<!-- Title -->
		<td class="table-cell overflow-hidden">
			<div class="flex items-center gap-2 min-w-0">
				<!-- Favicon -->
				<div class="w-6 h-6 bg-muted flex items-center justify-center text-xs text-muted-foreground shrink-0 overflow-hidden">
					<img
						src={ bookmark.GetFaviconURL() }
						alt=""
						class="w-4 h-4 object-contain"
						loading="lazy"
						onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"
					/>
					<span class="hidden items-center justify-center w-full h-full text-[10px]">{ getFirstLetter(bookmark.GetDomain()) }</span>
				</div>
				<div class="min-w-0 flex-1">
					<button
						type="button"
						hx-get={ "/admin/htmx/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) + "/edit-drawer" }
						hx-target="#drawer-content"
						hx-swap="innerHTML"
						onclick="window.drawerOpen('Edit Bookmark')"
						class="font-medium text-foreground hover:underline block truncate text-left cursor-pointer"
						title={ bookmark.Title }
					>
						{ bookmark.Title }
					</button>
					<a
						href={ templ.URL(bookmark.URL) }
						target="_blank"
						class="text-[11px] text-muted-foreground hover:underline truncate block"
						title={ bookmark.URL }
					>
						{ truncateURL(bookmark.URL, 50) }
					</a>
				</div>
			</div>
		</td>
		<!-- Collection (inline dropdown) -->
		<td class="table-cell">
			@BookmarkCollectionDropdown(bookmark.ID, bookmark.CollectionID.Int64, bookmark.CollectionID.Valid, collections, false)
		</td>
		<!-- Status (inline toggles) -->
		<td class="table-cell">
			<div class="flex items-center gap-1">
				@BookmarkPublicBadge(bookmark.ID, bookmark.IsPublic, false)
				@BookmarkFavoriteStar(bookmark.ID, bookmark.IsFavorite, false)
			</div>
		</td>
		<!-- Actions -->
		<td class="table-cell text-right">
			<div class="row-actions">
				<a
					href={ templ.URL(bookmark.URL) }
					class="btn-ghost btn-xs"
					target="_blank"
					title="Open link"
				>
					@components.ExternalLinkIcon(components.IconMD)
				</a>
				<a
					href={ templ.URL("/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) + "/edit") }
					class="btn-ghost btn-xs"
					title="Full edit"
				>
					@components.EditIcon(components.IconMD)
				</a>
				<button
					type="button"
					hx-delete={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
					hx-confirm="Delete this bookmark?"
					hx-target="closest tr"
					hx-swap="outerHTML swap:0.2s"
					class="btn-ghost btn-xs text-destructive hover:text-destructive"
					title="Delete"
				>
					@components.TrashIcon(components.IconMD)
				</button>
			</div>
		</td>
	</tr>
}

// BookmarkRowOOBPrepend renders a new bookmark row for out-of-band prepend after create
templ BookmarkRowOOBPrepend(bookmark models.Bookmark, collections []models.Collection) {
	<tbody id="bookmarks-tbody" hx-swap-oob="afterbegin">
		<tr
			id={ "bookmark-row-" + strconv.FormatInt(bookmark.ID, 10) }
			class="table-row group"
			data-title={ bookmark.Title }
			data-url={ bookmark.URL }
			data-domain={ bookmark.GetDomain() }
			data-collection-id={ getCollectionID(bookmark) }
			data-is-public={ strconv.FormatBool(bookmark.IsPublic) }
			data-is-favorite={ strconv.FormatBool(bookmark.IsFavorite) }
		>
			<!-- Title -->
			<td class="table-cell overflow-hidden">
				<div class="flex items-center gap-2 min-w-0">
					<!-- Favicon -->
					<div class="w-6 h-6 bg-muted flex items-center justify-center text-xs text-muted-foreground shrink-0 overflow-hidden">
						<img
							src={ bookmark.GetFaviconURL() }
							alt=""
							class="w-4 h-4 object-contain"
							loading="lazy"
							onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"
						/>
						<span class="hidden items-center justify-center w-full h-full text-[10px]">{ getFirstLetter(bookmark.GetDomain()) }</span>
					</div>
					<div class="min-w-0 flex-1">
				<button
					type="button"
						hx-get={ "/admin/htmx/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) + "/edit-drawer" }
						hx-target="#drawer-content"
						hx-swap="innerHTML"
						onclick="window.drawerOpen('Edit Bookmark')"
						class="font-medium text-foreground hover:underline block truncate text-left cursor-pointer"
						title={ bookmark.Title }
					>
						{ bookmark.Title }
					</button>
					<a
						href={ templ.URL(bookmark.URL) }
						target="_blank"
						class="text-[11px] text-muted-foreground hover:underline truncate block"
						title={ bookmark.URL }
					>
						{ truncateURL(bookmark.URL, 50) }
					</a>
				</div>
				</div>
			</td>
			<!-- Collection (inline dropdown) -->
			<td class="table-cell">
				@BookmarkCollectionDropdown(bookmark.ID, bookmark.CollectionID.Int64, bookmark.CollectionID.Valid, collections, false)
			</td>
			<!-- Status (inline toggles) -->
			<td class="table-cell">
				<div class="flex items-center gap-1">
					@BookmarkPublicBadge(bookmark.ID, bookmark.IsPublic, false)
					@BookmarkFavoriteStar(bookmark.ID, bookmark.IsFavorite, false)
				</div>
			</td>
			<!-- Actions -->
			<td class="table-cell text-right">
				<div class="row-actions">
					<a
						href={ templ.URL(bookmark.URL) }
						class="btn-ghost btn-xs"
						target="_blank"
						title="Open link"
					>
						@components.ExternalLinkIcon(components.IconMD)
					</a>
					<a
						href={ templ.URL("/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) + "/edit") }
						class="btn-ghost btn-xs"
						title="Full edit"
					>
						@components.EditIcon(components.IconMD)
					</a>
					<button
						type="button"
						hx-delete={ "/admin/bookmarks/" + strconv.FormatInt(bookmark.ID, 10) }
						hx-confirm="Delete this bookmark?"
						hx-target="closest tr"
						hx-swap="outerHTML swap:0.2s"
						class="btn-ghost btn-xs text-destructive hover:text-destructive"
						title="Delete"
					>
						@components.TrashIcon(components.IconMD)
					</button>
				</div>
			</td>
		</tr>
	</tbody>
}
